{
    "componentChunkName": "component---node-modules-gatsby-philipps-foam-theme-src-templates-local-file-jsx",
    "path": "/Typescript Strict Check Staged",
    "result": {"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"typesscript-strict-check-staged\"\n  }, \"TypesScript Strict Check Staged\"), mdx(\"p\", null, \"This script is intended to be used along with an array of changed files. It will run strict TS checks but only\\nshow errors relating to files you have provided, not the whole project. This can be useful when you are converting\\na non strict codebase to strict incrementally.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"#!/usr/bin/env node\\n\\n/* eslint-disable no-console */\\nconst { execSync, spawnSync } = require(\\\"child_process\\\");\\nconst { writeFileSync } = require(\\\"fs\\\");\\n\\nconst TEMP_FILE_NAME = \\\".tsconfig-lint.json\\\";\\n\\nconst colour = {\\n    red: (input) => `\\\\x1b[91m${input}\\\\x1b[0m`,\\n    underline: (input) => `\\\\x1b[4m${input}\\\\x1b[0m`,\\n    subtle: (input) => `\\\\x1b[2m${input}\\\\x1b[0m`,\\n};\\n\\nfunction checkTypescriptStrict() {\\n    const STAGED_FILES = process.argv.slice(2);\\n    const joinedFiles = STAGED_FILES.map((path) => `\\\\\\\"${path}\\\\\\\"`).join(\\\",\\\");\\n\\n    // We only want staged files \\\"included\\\" in our temporary tsconfig\\n    // Also include all our custom type definition files\\n    const tempTsConfig = `{ \\\"extends\\\": \\\"./tsconfig.json\\\", \\\"include\\\": [${joinedFiles}, \\\"**/*.d.ts\\\"] }`;\\n    writeFileSync(TEMP_FILE_NAME, tempTsConfig);\\n\\n    const tscResult = spawnSync(\\\"npx tsc --project .tsconfig-lint.json --noEmit --skipLibCheck\\\", {\\n        shell: true,\\n    });\\n\\n    /*\\n     * Split stdout by each line\\n     *\\n     * Input:\\n     * src/example/FormValidators.ts(63,36): error TS2571: Object is of type 'unknown'.\\n     * src/example/FormValidators.ts(65,7): error TS2322: Type '(value: string, message: string) => string | undefined' is not assignable to type 'ValidatorFn'.\\n     *   Types of parameters 'value' and 'value' are incompatible.\\n     *     Type 'unknown' is not assignable to type 'string'.\\n     *\\n     * Regex: Split on new line\\n     *\\n     * Output:\\n     * [\\n     *  \\\"src/example/FormValidators.ts(63,36): error TS2571: Object is of type 'unknown'.\\\",\\n     *  \\\"src/example/FormValidators.ts(65,7): error TS2322: Type '(value: string, message: string) => string | undefined' is not assignable to type 'ValidatorFn'.\\\",\\n     *   \\\"  Types of parameters 'value' and 'value' are incompatible.\\\",\\n     *   \\\"    Type 'unknown' is not assignable to type 'string'.\\\"\\n     * ]\\n     */\\n    const allErrors = tscResult.stdout.toString(\\\"utf-8\\\").split(/\\\\n/g);\\n\\n    const stagedFileErrors = [];\\n\\n    for (let i = 0; i < allErrors.length; ) {\\n        const error = allErrors[i];\\n        if (STAGED_FILES.some((filePath) => error.includes(filePath))) {\\n            // The filename is included in staged files\\n            stagedFileErrors.push(error);\\n            /*\\n             * Keep matching lines if they start with any whitespace\\n             * Any indented lines are describing the error before so are all relevant\\n             *\\n             * Regex: Match any line that begins with 1 or more whitespace character\\n             */\\n            while (++i < allErrors.length && allErrors[i].match(/^\\\\s+/)) {\\n                stagedFileErrors.push(allErrors[i]);\\n            }\\n        } else {\\n            /* The filename is not included in staged files\\n             * Any indented files are details for this error, so skip them too\\n             *\\n             * Regex: Match any line that begins with 1 or more whitespace character\\n             */\\n            // eslint-disable-next-line no-empty\\n            while (++i < allErrors.length && allErrors[i].match(/^\\\\s+/)) {}\\n        }\\n    }\\n\\n    const errorMap = {};\\n\\n    // Group errors from same files together\\n    for (let i = 0; i < stagedFileErrors.length; ) {\\n        const input = stagedFileErrors[i];\\n        /*\\n         * Split the error line into file name and line number, preserving the error\\n         *\\n         * Input: \\\"src/example/FormValidators.ts(63,36): error TS2571: Object is of type 'unknown'.\\\"\\n         *\\n         * Regex: Split the string using \\\":\\\".\\n         *        The grouped parameter (everything after \\\":\\\") is spliced into the result array.\\n         *\\n         * Output: [\\\"src/example/FormValidators.ts(63,36)\\\", \\\"  error TS2571: Object is of type 'unknown'.\\\"]\\n         */\\n        const [fileAndLine, error] = input.split(/:(.+)/);\\n        const details = [];\\n\\n        /*\\n         * Split the filename and line number\\n         *\\n         * Input: \\\"src/example/FormValidators.ts(63,36)\\\"\\n         *\\n         * Regex: Split the string by matching the line number and position.\\n         *        Since they are grouped, they also are spliced into the matching array.\\n         *\\n         * Output: [\\\"src/example/FormValidators.ts\\\", \\\"(63,36)\\\"]\\n         */\\n        const [fileName, lineNumber] = fileAndLine.split(/(\\\\(\\\\d+,\\\\d+\\\\))/g);\\n\\n        // Format line number to mirror eslint output\\n        const formattedLineNumber = lineNumber\\n            .replace(/[()]/g, \\\"\\\")\\n            .replace(/,/g, \\\":\\\")\\n            .padStart(9, \\\" \\\");\\n\\n        /*\\n         * Push any indented lines into the details array.\\n         * All indented lines are relevant to the base error.\\n         *\\n         * Regex: Match any line that begins with 1 or more whitespace character\\n         */\\n        while (++i < stagedFileErrors.length && stagedFileErrors[i].match(/^\\\\s+/)) {\\n            details.push(stagedFileErrors[i]);\\n        }\\n\\n        // Isolate TS error code and the error\\n        const [tsCodeAndType, errorText] = error.split(/:(.+)/);\\n        // Isolate TS code and error type (always error)\\n        const [type, tsCode] = tsCodeAndType.trim().split(\\\" \\\");\\n\\n        const logLine = [\\n            colour.subtle(formattedLineNumber),\\n            colour.red(type),\\n            errorText.trim(),\\n            colour.subtle(tsCode),\\n        ].join(\\\" \\\");\\n\\n        errorMap[fileName] = [\\n            ...(errorMap?.[fileName] ? errorMap[fileName] : []),\\n            logLine,\\n            ...details.map((detail) => `\\\\t\\\\t${detail}`),\\n        ];\\n    }\\n\\n    Object.entries(errorMap).forEach(([fileName, errors]) => {\\n        const numErrorsInFile = errors.filter((err) => !err.match(/^\\\\s/)).length;\\n        console.error(\\n            `${colour.underline(fileName)} ${colour.subtle(`${numErrorsInFile} error(s)`)}`\\n        );\\n        console.log(errors.join(\\\"\\\\n\\\"));\\n        console.log(\\\"\\\\n\\\");\\n    });\\n\\n    execSync(`rm ${TEMP_FILE_NAME}`);\\n\\n    if (stagedFileErrors.length) {\\n        process.exit(1);\\n    }\\n\\n    process.exit(0);\\n}\\n\\ncheckTypescriptStrict();\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"depth":1,"value":"TypesScript Strict Check Staged"}],"outboundReferences":[],"inboundReferences":[{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"typescript\"\n  }, \"TypeScript\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"foamlink\", {\n    parentName: \"li\"\n  }, \"Event Listener Handler Map React\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"foamlink\", {\n    parentName: \"li\"\n  }, \"Redux Observable Ajax Default Header Hack\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"foamlink\", {\n    parentName: \"li\"\n  }, \"Union Array to Array Union\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"foamlink\", {\n    parentName: \"li\"\n  }, \"TypesScript Strict Check Staged\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"2673547a-78fa-577b-9767-29c9ec32d0fa","fields":{"slug":"/TypeScript","title":"TypeScript"}}}]},"fields":{"slug":"/Typescript Strict Check Staged","title":"TypesScript Strict Check Staged"}}},"pageContext":{"id":"b1d126c1-1be6-5c33-82b3-6dd633741461"}},
    "staticQueryHashes": ["1968664781","2221750479","2468095761","2557268104","3120354889","654337312"]}