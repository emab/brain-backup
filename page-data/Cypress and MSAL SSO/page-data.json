{
    "componentChunkName": "component---node-modules-gatsby-philipps-foam-theme-src-templates-local-file-jsx",
    "path": "/Cypress and MSAL SSO",
    "result": {"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"cypress-and-msal-sso\"\n  }, \"Cypress and MSAL SSO\"), mdx(\"p\", null, \"Created an application that used \", mdx(\"foamlink\", {\n    parentName: \"p\"\n  }, \"Azure SSO Integration\"), \" and wanted to test with Cypress. I was thinking about bypassing the login altogether but the doucmentation advised against this.\"), mdx(\"p\", null, \"Instead of skipping authentication or manually typing in a username and password each time, you should inject the relevant information into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sessionStorage\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"localStorage\"), \".\"), mdx(\"h3\", {\n    \"id\": \"requirements\"\n  }, \"Requirements:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Azure AD Tenant\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Worth creating a seperate one for testing environment\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Create the API / App applications as described in \", mdx(\"foamlink\", {\n    parentName: \"li\"\n  }, \"Azure SSO Integration\"), \"\")), mdx(\"h2\", {\n    \"id\": \"cypress-setup\"\n  }, \"Cypress Setup\"), mdx(\"p\", null, \"First you'll need to store some secrets in Cypress to be used when getting auth details:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"// support/authSettings.json\\n{\\n  \\\"authority\\\": \\\"https://login.microsoftonline.com/your-aad-tenant-id\\\",\\n  \\\"clientId\\\": \\\"app-client-id\\\",\\n  \\\"apiScopes\\\": [\\\"api://api-client-id/Data.Read\\\"],\\n  \\\"username\\\": \\\"user@yourcompany.onmicrosoft.com\\\",\\n    \\n  // These are both very secret\\n  \\\"clientSecret\\\": \\\"app-client-secret\\\",\\n  \\\"password\\\": \\\"password\\\"\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WARNING\"), \"\\nYou should \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" check in the test users \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clientSecret\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"password\"), \" into VCS. See \", mdx(\"foamlink\", {\n    parentName: \"p\"\n  }, \"Azure Key Vault JavaScript\"), \" for a way to inject these variables, or share them in some other secure way.\"), mdx(\"p\", null, \"Along with the following support file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// support/auth.ts\\n\\nimport { decode } from \\\"jsonwebtoken\\\";  \\nimport * as authSettings from \\\"./authsettings.json\\\";  \\nimport Chainable = Cypress.Chainable;  \\nimport AUTWindow = Cypress.AUTWindow;  \\n  \\n/*  \\n * Adapted from https://github.com/juunas11/AzureAdUiTestAutomation \\n */  \\n\\ntype TokenResponseBody = {  \\n  access_token: string;  \\n  expires_in: number;  \\n  ext_expires_in: number;  \\n  id_token: string;  \\n};  \\n  \\ntype TokenResponse = {  \\n  body: TokenResponseBody;  \\n  status: number;  \\n};  \\n  \\nconst { \\n    authority, \\n    clientId, \\n    apiScopes, \\n    username, \\n    clientSecret, \\n    password } = authSettings;  \\nconst environment = \\\"login.windows.net\\\";  \\n  \\nconst buildAccountEntity = (  \\n  homeAccountId,  \\n realm,  \\n localAccountId,  \\n username,  \\n name  \\n) => ({  \\n  authorityType: \\\"MSSTS\\\",  \\n  clientInfo: \\\"\\\",  \\n  homeAccountId,  \\n  environment,  \\n  realm,  \\n  localAccountId,  \\n  username,  \\n  name,  \\n});  \\n  \\nconst buildIdTokenEntity = (homeAccountId, idToken, realm) => ({  \\n  credentialType: \\\"IdToken\\\",  \\n  homeAccountId,  \\n  environment,  \\n  clientId,  \\n  secret: idToken,  \\n  realm,  \\n});    \\n  \\nconst buildAccessTokenEntity = (  \\n  homeAccountId,  \\n accessToken,  \\n expiresIn,  \\n extExpiresIn,  \\n realm,  \\n scopes  \\n) => {  \\n  const now = Math.floor(Date.now() / 1000);  \\n   return {  \\n    homeAccountId,  \\n     credentialType: \\\"AccessToken\\\",  \\n     secret: accessToken,  \\n     cachedAt: now.toString(),  \\n     expiresOn: (now + expiresIn).toString(),  \\n     extendedExpiresOn: (now + extExpiresIn).toString(),  \\n     environment,  \\n     clientId,  \\n     realm,  \\n     target: scopes.map((s) => s.toLowerCase()).join(\\\" \\\"),  \\n   };  \\n};  \\n  \\nconst injectTokens = (tokenResponse) => {  \\n  const idToken = decode(tokenResponse.id_token);  \\n  const localAccountId = idToken.oid || idToken.sid;  \\n  const realm = idToken.tid;  \\n    const homeAccountId = `${localAccountId}.${realm}`;  \\n    const username = idToken.preferred_username;  \\n    const name = idToken.name;  \\n  \\n    const accountKey = `${homeAccountId}-${environment}-${realm}`;  \\n    const accountEntity = buildAccountEntity(  \\n      homeAccountId,  \\n      realm,  \\n      localAccountId,  \\n      username,  \\n      name  \\n     );  \\n  \\n const idTokenKey = \\n       `${homeAccountId}-${environment}-idtoken-${clientId}-${realm}-`;  \\n const idTokenEntity = buildIdTokenEntity(  \\n    homeAccountId,  \\n    tokenResponse.id_token,  \\n    realm  \\n  );  \\n  \\n const accessTokenKey = \\n       `${homeAccountId}-${environment}-accesstoken-${clientId}-${realm}-${apiScopes.join(  \\n    \\\" \\\")}`;  \\n const accessTokenEntity = buildAccessTokenEntity(  \\n    homeAccountId,  \\n    tokenResponse.access_token,  \\n    tokenResponse.expires_in,  \\n    tokenResponse.ext_expires_in,  \\n    realm,  \\n    apiScopes  \\n  );  \\n  \\n sessionStorage.setItem(accountKey, JSON.stringify(accountEntity));  \\n sessionStorage.setItem(idTokenKey, JSON.stringify(idTokenEntity));  \\n sessionStorage.setItem(accessTokenKey, JSON.stringify(accessTokenEntity));  \\n};  \\n  \\nexport const login = (  \\n  cachedTokenResponse: TokenResponse  \\n): Chainable<Cypress.Response<any>> => {  \\n  let tokenResponse = null;  \\n  let chainable: Chainable<AUTWindow> | Chainable<Cypress.Response<any>> =  \\n    cy.visit(\\\"/\\\");  \\n  \\n  if (!cachedTokenResponse) {  \\n     chainable = chainable.request({  \\n       url: authority + \\\"/oauth2/v2.0/token\\\",  \\n       method: \\\"POST\\\",  \\n       body: {  \\n         grant_type: \\\"password\\\",  \\n         client_id: clientId,  \\n         client_secret: clientSecret,  \\n         scope: [\\\"openid profile\\\"].concat(apiScopes).join(\\\" \\\"),  \\n         username,  \\n         password,  \\n       },  \\n       form: true,  \\n     });  \\n   } else {  \\n     chainable.then(() => {  \\n       return {  \\n         body: cachedTokenResponse,  \\n       };  \\n   });  \\n }  \\n  (chainable as Chainable<Cypress.Response<any>>)  \\n    .then((response: TokenResponse) => {  \\n      injectTokens(response.body);  \\n   tokenResponse = response.body;  \\n   })  \\n   .reload()  \\n   .then(() => {  \\n     return tokenResponse;  \\n });  \\n  \\n return chainable as Chainable<Cypress.Response<any>>;  \\n};\\n\")), mdx(\"p\", null, \"This file is responsible for making a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"POST\"), \" request to Azure AD and setting the session storage with your credentials.\"), mdx(\"p\", null, \"We can now add the exposed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"login\"), \" function to Cypress:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// support/commands.ts\\n\\nlet cachedTokenExpiryTime = new Date().getTime();  \\nlet cachedTokenResponse = null;  \\n  \\nCypress.Commands.add(\\\"login\\\", () => {  \\n  // Clear our cache if tokens are expired  \\n if (cachedTokenExpiryTime <= new Date().getTime()) {  \\n    cachedTokenResponse = null;  \\n }  \\n  \\n  return login(cachedTokenResponse).then((tokenResponse) => {  \\n    cachedTokenResponse = tokenResponse;  \\n    // Set expiry time to 50 minutes from now  \\n    cachedTokenExpiryTime = new Date().getTime() + 50 * 60 * 1000;  \\n  });  \\n});\\n\")), mdx(\"p\", null, \"You should also add a type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// support/index.ts\\n\\n// ***********************************************************  \\n// This example support/index.js is processed and  \\n// loaded automatically before your test files.  \\n//  \\n// This is a great place to put global configuration and  \\n// behavior that modifies Cypress.  \\n//  \\n// You can change the location of this file or turn off  \\n// automatically serving support files with the  \\n// 'supportFile' configuration option.  \\n//  \\n// You can read more here:  \\n// https://on.cypress.io/configuration  \\n// ***********************************************************  \\n  \\n// Import commands.js using ES2015 syntax:  \\nimport \\\"./commands\\\";  \\n  \\n// Alternatively you can use CommonJS syntax:  \\n// require('./commands')  \\ndeclare global {  \\n  namespace Cypress {  \\n    interface Chainable {  \\n      login(): Chainable<Cypress.Response<any>>;  \\n }  \\n  }  \\n}\\n\")), mdx(\"p\", null, \"Now you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"login\"), \" command to skip your splash screen and authenticated a user! \\uD83C\\uDF89\"), mdx(\"p\", null, \"Example usage:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"cy.login().visit(\\\"/secure\\\");\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"depth":1,"value":"Cypress and MSAL SSO"},{"depth":3,"value":"Requirements:"},{"depth":2,"value":"Cypress Setup"}],"outboundReferences":[{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"azure-sso-integration\"\n  }, \"Azure SSO Integration\"), mdx(\"p\", null, \"Done with a React front-end application and a Spring Boot back-end.\"), mdx(\"p\", null, \"Implementation was quite straight forward, and enabled a JWT token to be used to authorize requests from the front-end to the back-end.\"), mdx(\"h2\", {\n    \"id\": \"requirements\"\n  }, \"Requirements\"), mdx(\"h3\", {\n    \"id\": \"cloud\"\n  }, \"Cloud\"), mdx(\"p\", null, \"You'll need an Active Directory initially. From here you create two app registrations, one for the API and one for the App.\"), mdx(\"h4\", {\n    \"id\": \"api\"\n  }, \"API\"), mdx(\"p\", null, \"In the API configuration you should add scopes via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Expose an API\"), \". Add an Application URI here then add a scope such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User.Access\"), \". This should give you something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"api://0000000-0000-0000-0000-0000000/User.Access\\n\")), mdx(\"p\", null, \"Below this you should also add the App as a client application.\"), mdx(\"h4\", {\n    \"id\": \"app\"\n  }, \"App\"), mdx(\"p\", null, \"The App authentication should be set up to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Access Tokens (used for implicit flows)\"), \" and include suitable redirect URIs for login callbacks.\"), mdx(\"p\", null, \"You should then go to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"API Permissions\"), \" and add the scope we saw above as a permission.\"), mdx(\"p\", null, \"This should now allow a token to be created from the front-end using the scope defined in the API, which will then be decoded by Spring Boot.\"), mdx(\"h3\", {\n    \"id\": \"front-end\"\n  }, \"Front-end\"), mdx(\"p\", null, \"Used the new provided packages from Azure, which provide some handy hooks for authentication if you're using functional components.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@azure/msal-browser\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@azure/msal-react\"))), mdx(\"p\", null, \"Also provide some basic auth config:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const msalConfig = {\\n  auth: {\\n    clientId: '<app-registration-client-id>',\\n    authority:\\n      'https://login.microsoftonline.com/<AAD-resource-id>',\\n  },\\n  cache: {\\n    cacheLocation: 'sessionStorage',\\n  },\\n};\\n\\nexport const loginRequest = {\\n  // this corresponds to the User.Read scope for accessing the\\n  // Azure Graph API which holds user info \\n  scopes: ['User.Read'],\\n};\\n\\n// this scope comes from the Azure App Registration setup\\n// This will be the API app url and scope which the front-end will try\\n// to use when authenticating with token\\nexport const USER_API_SCOPE =\\n  'api://<api-url-from-azure>/<Some.Scope>';\\n\")), mdx(\"p\", null, \"Getting and using a token is also straightforward. The below example uses the scope from the file above to request a token - different tokens could be substituted here:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export default async (\\n  instance: IPublicClientApplication,\\n  account: AccountInfo\\n): Promise<string> => {\\n  const tokenResult = await instance.acquireTokenSilent({\\n    scopes: [USER_API_SCOPE],\\n    account,\\n  });\\n\\n  return tokenResult.accessToken;\\n};\\n\")), mdx(\"h3\", {\n    \"id\": \"back-end\"\n  }, \"Back-end\"), mdx(\"p\", null, \"You'll need a couple of dependencies for Spring Boot and Azure to work nicely:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"org.springframework.boot:spring-boot-starter-security\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"com.azure.spring:azure-spring-boot-starter-active-directory\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"org.springframework.boot:spring-boot-starter-oauth2-resource-server\"))), mdx(\"p\", null, \"The configuration is minimal for newer versions of Spring Boot:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"import com.azure.spring.aad.webapi.AADResourceServerWebSecurityConfigurerAdapter;\\nimport org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;\\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\\n\\n@EnableWebSecurity\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\npublic class AADOAuth2ResourceServerSecurityConfig extends AADResourceServerWebSecurityConfigurerAdapter {\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        super.configure(http);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Remember to add this to your main application if you didn't already:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"// Web security\\n@EnableWebSecurity\\n@SpringBootApplication\\npublic class ApiApplication {\\n    public static void main(String[] args) {\\n        SpringApplication.run(ApiApplication.class, args);\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can then check for authorities like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"@RestController\\npublic class HelloController {\\n\\n    @GetMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority('SCOPE_User.Access')\\\")\\n    public MessageResponse authenticated() {\\n        return new MessageResponse(\\\"Authenticated with API with correct scope!\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"I needed the following in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"application.properties\"), \" in order for this to work properly:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-properties\"\n  }, \"azure.activedirectory.tenant-id=<azure-active-directory-tenant-id>\\nazure.activedirectory.client-id=<the-id-of-the-frontend-application>\\n# looks like api://0000000-0000-0000-0000-0000000\\n# we put it before the scope used in the front-end earlier\\nazure.activedirectory.app-id-uri=<the-app-uri-created-in-api-app-registration-page>\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"id":"1a6c50ef-bab3-567d-b8a0-b65eb9c0da49","fields":{"slug":"/Azure SSO Integration","title":"Azure SSO Integration"}}},{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"azure-key-vault-javascript\"\n  }, \"Azure Key Vault JavaScript\"), mdx(\"p\", null, \"Recently created a project that used Azure AD for single sign-on, and I set up \", mdx(\"foamlink\", {\n    parentName: \"p\"\n  }, \"Cypress and MSAL SSO\"), \" and came across a classic problem - how do I store and share the secrets across the team?\"), mdx(\"p\", null, \"I've used Azure Key Vault before on a C# project and it worked really well, as it used your Microsoft account to check your permissions in the Azure AD and could automatically inject env variables into your code when running it.\"), mdx(\"p\", null, \"Luckily there are some Azure provided libraries to handle this in JavaScript, and below is the file I used to grab and set some environment variables when running Cyoress.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { SecretClient } from \\\"@azure/keyvault-secrets\\\";\\nimport { DefaultAzureCredential } from \\\"@azure/identity\\\";\\n\\nconst { execSync } = require(\\\"child_process\\\");\\n\\n// Azure KV Secret names\\nconst AZURE_AD_CLIENT_SECRET_NAME = \\\"test-ad-client-secret\\\";\\nconst AZURE_AD_PASSWORD_NAME = \\\"test-ad-password\\\";\\n\\n// Azure KV URL\\nconst AZURE_KV_URL = \\\"https://my-kv.vault.azure.net/\\\";\\n\\nasync function main() {\\n  const credential = new DefaultAzureCredential();\\n  const client = new SecretClient(AZURE_KV_URL, credential);\\n\\n  // get the secrets\\n  const { value: AZURE_AD_CLIENT_SECRET } = await client.getSecret(\\n    AZURE_AD_CLIENT_SECRET_NAME\\n  );\\n  const { value: AZURE_AD_PASSWORD } = await client.getSecret(\\n    AZURE_AD_PASSWORD_NAME\\n  );\\n\\n  const ENV_VARS = {\\n    AZURE_AD_CLIENT_SECRET,\\n    AZURE_AD_PASSWORD,\\n  };\\n\\n  const ENV_STRING = Object.keys(ENV_VARS)\\n    .map((key) => `${key}=${ENV_VARS[key]}`)\\n    .join(\\\",\\\");\\n\\n  // run cypress with secrets\\n  execSync(`npm run cypress:open -- --env ${ENV_STRING}`);\\n}\\n\\nmain().catch((error) => {\\n  console.error(\\\"An error occurred:\\\", error);\\n  process.exit(1);\\n});\\n\\n\")), mdx(\"p\", null, \"I was also considering writing a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"preinstall\"), \" script which just writes the variables to a file, but that comes with the risk of them being accidentally committed.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"id":"eff4e3b2-2f31-51eb-8cf8-50ed3505b438","fields":{"slug":"/Azure Key Vault JavaScript","title":"Azure Key Vault JavaScript"}}}],"inboundReferences":[{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"todo\"\n  }, \"Todo\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Add \", mdx(\"foamlink\", {\n    parentName: \"li\"\n  }, \"Cypress and MSAL SSO\"), \" stuff\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"19ff8983-105d-5fbb-81a6-3980332d1d66","fields":{"slug":"/todo","title":"Todo"}}},{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"azure-key-vault-javascript\"\n  }, \"Azure Key Vault JavaScript\"), mdx(\"p\", null, \"Recently created a project that used Azure AD for single sign-on, and I set up \", mdx(\"foamlink\", {\n    parentName: \"p\"\n  }, \"Cypress and MSAL SSO\"), \" and came across a classic problem - how do I store and share the secrets across the team?\"), mdx(\"p\", null, \"I've used Azure Key Vault before on a C# project and it worked really well, as it used your Microsoft account to check your permissions in the Azure AD and could automatically inject env variables into your code when running it.\"), mdx(\"p\", null, \"Luckily there are some Azure provided libraries to handle this in JavaScript, and below is the file I used to grab and set some environment variables when running Cyoress.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { SecretClient } from \\\"@azure/keyvault-secrets\\\";\\nimport { DefaultAzureCredential } from \\\"@azure/identity\\\";\\n\\nconst { execSync } = require(\\\"child_process\\\");\\n\\n// Azure KV Secret names\\nconst AZURE_AD_CLIENT_SECRET_NAME = \\\"test-ad-client-secret\\\";\\nconst AZURE_AD_PASSWORD_NAME = \\\"test-ad-password\\\";\\n\\n// Azure KV URL\\nconst AZURE_KV_URL = \\\"https://my-kv.vault.azure.net/\\\";\\n\\nasync function main() {\\n  const credential = new DefaultAzureCredential();\\n  const client = new SecretClient(AZURE_KV_URL, credential);\\n\\n  // get the secrets\\n  const { value: AZURE_AD_CLIENT_SECRET } = await client.getSecret(\\n    AZURE_AD_CLIENT_SECRET_NAME\\n  );\\n  const { value: AZURE_AD_PASSWORD } = await client.getSecret(\\n    AZURE_AD_PASSWORD_NAME\\n  );\\n\\n  const ENV_VARS = {\\n    AZURE_AD_CLIENT_SECRET,\\n    AZURE_AD_PASSWORD,\\n  };\\n\\n  const ENV_STRING = Object.keys(ENV_VARS)\\n    .map((key) => `${key}=${ENV_VARS[key]}`)\\n    .join(\\\",\\\");\\n\\n  // run cypress with secrets\\n  execSync(`npm run cypress:open -- --env ${ENV_STRING}`);\\n}\\n\\nmain().catch((error) => {\\n  console.error(\\\"An error occurred:\\\", error);\\n  process.exit(1);\\n});\\n\\n\")), mdx(\"p\", null, \"I was also considering writing a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"preinstall\"), \" script which just writes the variables to a file, but that comes with the risk of them being accidentally committed.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"eff4e3b2-2f31-51eb-8cf8-50ed3505b438","fields":{"slug":"/Azure Key Vault JavaScript","title":"Azure Key Vault JavaScript"}}}]},"fields":{"slug":"/Cypress and MSAL SSO","title":"Cypress and MSAL SSO"}}},"pageContext":{"id":"ea972831-d62c-59b4-97e4-f77cae8dca3e"}},
    "staticQueryHashes": ["1968664781","2221750479","2468095761","2557268104","3120354889","654337312"]}