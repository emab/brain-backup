{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Complexity","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"complexity\"\n  }, \"Complexity\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Time-Complexity\",\n    \"title\": \"Time Complexity\"\n  }, \"[[Time Complexity]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Space-Complexity\",\n    \"title\": \"Space Complexity\"\n  }, \"[[Space Complexity]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"time-complexity\"\n  }, \"Time Complexity\"), mdx(\"p\", null, \"See also: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Space-Complexity\",\n    \"title\": \"Space Complexity\"\n  }, \"[[Space Complexity]]\"), \"\"), mdx(\"p\", null, \"Describes the amount of computer time it takes to run an algorithm. It is usually estimated by counting the number of elementary operations performed.\"), mdx(\"p\", null, \"Since an algorithms running time may different depending on a certain input, you'd usually consider the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"worst-case\"), \" time complexity i.e the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"maximum\"), \" amount of time. Another option is to use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"average-case\"), \" complexity.\"), mdx(\"p\", null, \"Commonly expressed in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"big O notation\"), \": $O(n)$, $O(n \\\\log n)$, $O(n ^a)$, $O(2^n)$, etc...\"), mdx(\"p\", null, \"Complexities are classified according to the big O notation, for example an algorithm with time complexity is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"linear time algorithm\"), \".\"), mdx(\"h2\", {\n    \"id\": \"constant-time\"\n  }, \"Constant time\"), mdx(\"p\", null, \"An algorithm is constant time ($O(1)$) if the computer time does not depend on the size of the input. For example, accessing a single element in an array takes constant time as only one operation is performed to locate it. Similarly, finding the smallest value in a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sorted\"), \" array also takes $O(n)$ time as we know it is the first element.\"), mdx(\"p\", null, \"Despite being called constant time, the time doesn't have to be completely independent of problem size - but the upper bound running time has to be bounded independently of the problem size.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"int index = 5;\\nint item = list[index];\\nif (condition true) then\\n    perform some operation that runs in constant time\\nelse\\n    perform some other operation that runs in constant time\\nfor i = 1 to 100\\n    for j = 1 to 200\\n        perform some operation that runs in constant time\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://en.wikipedia.org/wiki/Time_complexity\"\n  }, \"Source\"))), mdx(\"h2\", {\n    \"id\": \"logarithmic-time\"\n  }, \"Logarithmic time\"), mdx(\"p\", null, \"An algorithm takes logarithmic time when its big O notation is $O(\\\\log n)$. Algorithms that take logarithmic time are considered to be highly efficient as the ratio of operations to the size of input decreases as $n$ increases.\"), mdx(\"p\", null, \"Examples of logarithmic algorithms are often found in operations on binary tress or when using binary search, since these algorithms do not need to access all elements in order to finish.\"), mdx(\"p\", null, \"For example, a search for a number in a sorted list of numbers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"int searchNumber = 50;\\nboolean found = false;\\nint index = Math.floor(list.length / 2);\\n\\nwhile (not found) then\\n    int nextIndex;\\n    if (list[index] equals searchNumber) then\\n        found = true\\n    else if (list[index] is greater than searchNumber) then\\n        nextIndex = Math.floor(index / 2)\\n    else if (list[index] is less than searchNumber) then\\n        nextIndex = index + Math.floor(index / 2);\\n    \\n    if (nextIndex equals index) then\\n        was not found\\n\\nif (found) then\\n    return index\\n\")), mdx(\"h2\", {\n    \"id\": \"quadratic-time\"\n  }, \"Quadratic time\"), mdx(\"p\", null, \"A quadratic algorithm has a big O notation of $O(n^2)$. Simple comparison based sorting algorithms are quadratic (e.g. insertion sort).\"), mdx(\"p\", null, \"An example of searching for duplicate names in a string array:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"for (i = 0; i < input length; i++) do\\n    String name = input[i];\\n\\n    for (j = i + 1; j < input.length; j++) do\\n        if (name equals input[j]) then\\n            return true;\\n\\nreturn false;\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"There are $n-1$ iterations of the outer loop. On each iteration, the inner loop iterates $n-i-1$ times. So in total the inner loop iterates $n-1 + n-2 + ... + 1$ times. So the number of times that \", \"[the inner function]\", \" executes is equal to the sum of the numbers from 1 to n-1. That sum is $n*(n-1)/2$ , which is in $T(n^2)$ and thus also in $O(n^2)$ .\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/18459727/big-o-time-complexity-for-nested-j-i-1-loop\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Source\")))), mdx(\"h2\", {\n    \"id\": \"exponential-time\"\n  }, \"Exponential time\"), mdx(\"p\", null, \"An example of an algorithm that has a big O of $O(2^n)$ is a recursive Fibonacci function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"fibbonaci(int x)\\n    if (x is less than or equal to 1) then\\n        return 0;\\n    if (x equals 2) then\\n        return 1;\\n    \\n    return fibbonacci(x - 1) + fibbonacci(x - 2);\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"7e581758-07e6-52eb-8cd6-85674bd208f5","fields":{"slug":"/Time Complexity","title":"Time Complexity"}}},{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"space-complexity\"\n  }, \"Space Complexity\"), mdx(\"p\", null, \"See also: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Time-Complexity\",\n    \"title\": \"Time Complexity\"\n  }, \"[[Time Complexity]]\"), \"\"), mdx(\"p\", null, \"Similarly to time complexity, space complexity describes the amount of memory space required by an algorithm to solve a given problem.\"), mdx(\"h2\", {\n    \"id\": \"constant-space\"\n  }, \"Constant space\"), mdx(\"p\", null, \"A constant space ( $O(1)$ ) algorithm uses the same amount of memory no matter what the input size is.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sum (int a, int b)\\n    return a + b;\\n\")), mdx(\"p\", null, \"In this example, three variables are used and allocated in memory (3 int values). Therefore, this algorithm will take 12 bytes of memory to complete. No matter what inputs are used, this will always be the case, hence a constant space is used.\"), mdx(\"h2\", {\n    \"id\": \"linear-space\"\n  }, \"Linear space\"), mdx(\"p\", null, \"Linear space ( $O(n)$ ) algorithms use a linear amount of memory in relation to the input.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sumArray (int[] arr)\\n    int size = array.length;\\n    int sum = 0;\\n\\n    for (int i = 0; i < size; i++) do\\n        sum += array[i];\\n    \\n    return sum;\\n\")), mdx(\"p\", null, \"In this example we have 4 variables:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"arr\"), \": an array - $4 * n$ bytes, where $n$ is the length of the array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"size\"), \": int - 4 bytes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"sum\"), \": int - 4 bytes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"iterator\"), \": int - 4 bytes\")), mdx(\"p\", null, \"This gives us a total of $4n + 4 + 4 + 4$ . This therefore gives us the value $O(n)$ . \"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"14efa1a2-1ede-5b70-bd99-2b422bc5a4f7","fields":{"slug":"/Space Complexity","title":"Space Complexity"}}}],"inboundReferences":[{"__typename":"Mdx","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"brain-bank\"\n  }, \"Brain Bank\"), mdx(\"p\", null, \"Remember to check your \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/todo\",\n    \"title\": \"todo\"\n  }, \"[[todo]]\"), \" list and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/inbox\",\n    \"title\": \"inbox\"\n  }, \"[[inbox]]\"), \"!\"), mdx(\"h3\", {\n    \"id\": \"what-are-you-trying-to-remember\"\n  }, \"What are you trying to remember?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Complexity\",\n    \"title\": \"Complexity\"\n  }, \"[[Complexity]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Java\",\n    \"title\": \"Java\"\n  }, \"[[Java]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Event-Listener-Handler-Map-React\",\n    \"title\": \"Event Listener Handler Map React\"\n  }, \"[[Event Listener Handler Map React]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8a6beacf-aa62-526e-9ef1-627e9e2d444a","fields":{"slug":"/index","title":"Brain Bank"}}}]},"fields":{"slug":"/Complexity","title":"Complexity"}}},"pageContext":{"id":"0331909a-e048-5a72-a13c-840adf1d9f25"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}